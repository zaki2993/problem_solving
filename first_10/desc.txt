Problem 1: Two Sum
Problem Description

Find two indices in an array such that the numbers at those indices add up to a given target.

Rules

Only one valid solution exists.

The same element cannot be used twice.

Steps to Solve

Create a new sorted list from the original array.

Use two pointers:

First pointer → start of the list

Second pointer → end of the list

Compare their sum:

If sum > target → move right pointer left

If sum < target → move left pointer right

If sum == target → store the two numbers

Loop through the original array to find the indices.

Return the indices.

Learned

sorted() → returns a sorted list without modifying original

.copy() → creates a copy by value

Think before coding

Problem 2: Palindrome
Problem Description

A phrase is a palindrome if, after:

Converting uppercase to lowercase

Removing non-alphanumeric characters

It reads the same forward and backward.

Alphanumeric = letters + numbers

Method 1 — Extra List

Create empty list

Iterate string

Add lowercase character if alphanumeric

Compare list with reversed version

Method 2 — Two Pointers (Optimal)

i = 0, j = len(s) - 1

While i < j:

If s[i] not alphanumeric → i++

If s[j] not alphanumeric → j--

Compare lowercase values

If different → return False

Move both inward

Return True

Learned

.isalnum() → check alphanumeric

.isalpha() → check letters only

Slice format → [start:end:step]

Problem 3: Contains Duplicate
Problem Description

Return True if any number appears at least twice.
Return False if all elements are distinct.

Steps

Create empty set:

s = set()


Iterate through list

For each number:

If in set → return True

Else → add to set

Return False

Learned

if x in s → checks membership

Set lookup is O(1) average

Problem 4: Valid Anagram
Problem Description

Return True if string t is an anagram of string s.

Steps

Store lengths in variables

If lengths differ → return False

Create two empty dictionaries

Iterate through both strings:

If char not in dict → add with count 1

Else → increase count

Compare dictionaries

If equal → True else False

Learned

if x in dict → checks keys

Dictionary lookup is O(1) average

Problem 5: Reverse a Linked List
Problem Description

Reverse a singly linked list and return new head.

Step by Step

Create new pointer:

newlist = None


Traverse original list:

while head != None


Store current node:

temp = head


Move head forward:

head = head.next


Break original link:

temp.next = None


If new list empty:

newlist = temp


Else:

temp.next = newlist
newlist = temp


Return newlist

Linked List in Python
Node Definition
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

Create Linked List 1 → 2 → 3
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)

Python Assignment — Clear Summary
Type	Example	What a = b Does	If Modify a, Does b Change?	Why
int	a = 5	Reference copy	❌ No	Immutable
float	a = 3.14	Reference copy	❌ No	Immutable
string	a = "hi"	Reference copy	❌ No	Immutable
tuple	a = (1,2)	Reference copy	❌ No	Immutable
list	a = [1,2]	Reference copy	✅ Yes	Mutable
dict	a = {"x":1}	Reference copy	✅ Yes	Mutable
set	a = {1,2}	Reference copy	✅ Yes	Mutable
object	a = Person()	Reference copy	✅ Yes	Mutable
